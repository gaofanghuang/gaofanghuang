---
title: 设计模式、设计原则和反模式
date: 2020-03-10 15:03:09
tags:
- 反模式
- 设计模式
- 设计原则
categories: 编程相关
---

## 1. 设计模式

### 1.1 什么是设计模式？

模式是在某种情境下，针对某种问题的某种解决方案。 
设计模式算是一种经验复用。

### 1.2 为什么要使用设计模式？

1. 开发小组不需要重新设计解决方案来解决已经被前人解决过的问题。如此可以节省很多设计开发时间。

2. 当开发小组讨论设计的时候，使用设计模式可以使大家更好了理解问题所在和解决方案，而且对解决方案有一个比较统一的认知。

3. 设计模式本身已经通过了大量的实际运用和验证，其设计质量和实用价值有很好的保证。

4. 设计模式本身有健全的文档，可以一定程度上简化撰写开发文档。

<!--more-->

## 2. 设计模式的分类

### 2.1. 创建型

涉及到将对象实例化。

如：单例模式，工厂模式 

### 2.2. 结构型

把类或对象组合到更大的结构中。 

如：装饰器，代理模式，适配器模式 

### 2.3. 行为型

涉及到类和对象如何交互及分配职责。 

模板方法，观察者模式，策略模式

## 3. 什么是设计原则

### 3.1. 封装变化

找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起 

### 3.2. 针对接口编程

针对接口编程，而不是针对实现编程。此处的接口是指超类型，针对接口编程的意思是利用多态的能力，使得实际的类型可以动态绑定到真正需要的实现上。 

### 3.3. 多用组合

多用组合，少用继承。组合比继承更灵活。 

### 3.4. 松耦合设计

为了交互对象之间的松耦合设计而努力。这样会使我们的系统更有弹性，在应对新的需求时，由于对象之间的相互依赖降低到最低，从而需要修改的量最小。 

### 3.5. 开闭原则

开闭原则：类应该对扩展开放，对修改关闭。意思是在不修改现有类的代码情况下，扩展类可以满足新的需求。因为已有代码是精心设计的，修改容易产生BUG，而且精心设计的代码，是易于扩展的。 

### 3.6. 依赖导致原则

依赖导致原则：要依赖抽象，不要依赖具体类。 

### 3.7. 最少知识原则

最少知识原则：只和你的密友谈话。减少对象之间的交互。从而将受到影响而导致修改的可能性降到最低。 

### 3.8. 高层级调用

别调用我，我会调用你。这是组合高层组件和低层组件的一种原则。高层组件决定什么时候以及如何调用低层组件。低层组件只是挂在高层组件之下。 

### 3.9. 单一责任原则

对于一个模块，或者一个类来说，这个模块或者这个类应该只对系统/软件的一个功能负责，而且该责任应该被该类完全封装起来。

## 4. 常用的模式类型

### 4.1. 策略模式

定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。

### 4.2. 观察者模式

定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 

### 4.3. 装饰器模式

动态的将责任附加到对象上，若要扩展功能，装饰器提供了比继承更有弹性的替代方案。 

### 4.4. 工厂模式

简单的工厂模式，就是把对象的创建提出来单独处理。而标准的工厂模式，定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。

工厂方法让类把实例化推迟到子类。 

### 4.5. 抽象工厂模式

提供一个接口，用于创建相关或依赖对象的家族，而不需要明确确定具体类。 

### 4.6. 单例模式

确保一个类只有一个实例，并提供一个全局访问点。 

### 4.7. 命令模式

将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其它对象。

命令模式也支持可撤销的操作。 

### 4.8. 适配器模式

将一个类的接口，转换成客户期望的另一个接口。

适配器让原本接口不兼容的类可以合作无间。 

### 4.9. 外观模式

提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 

### 4.10. 模板方法模式

在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。

模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 

### 4.11. 迭代器模式

提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部的表示。 

### 4.12. 组合模式

允许你将对象组合成树形结构来表现『整体/部分』层次结构。

组合能让客户以一致的方式处理个别对象以及对象组合。 

### 4.13. 状态模式

允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 

### 4.14. 代理模式

为另一个对象提供一个替身或占位符以访问这个对象。

## 5. 反模式

### 5.1 什么是反模式

反模式是指在对经常面对的问题经常使用的低效、不良、或者有待优化的设计模式/方法。甚至，反模式也可以是一种错误的开发思想/理念。

### 5.2. 常见的反模式案例

**软件膨胀**：随着版本的升级，软件越来越消耗系统资源。

**反抽象**：需要的功能并不暴露给用户，导致用户要在较高层次重新实现一些功能。

**万能类**︰在一个类的设计中，聚集了太多的函数。

**硬编码(Hard Code)**：或称写死。在实现某系统用途上设死该系统的运作环境。

**超布尔逻辑**︰不必要的比较，或是过于抽象的布尔计算。

**剪贴编程(Copy-n-paste programming)**：宁愿拷贝(并修改)现存代码而非创造通用的解决方案。

## 扩展知识

1. [反模式wiki](http://zh.wikipedia.org/wiki/%E5%8F%8D%E6%A8%A1%E5%BC%8F)