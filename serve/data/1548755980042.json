{"id":"1548755980042","title":"canvas从入门到进阶\n","summary":"使用canvas可以在html5制作出各种绚丽的图表、动画，是制作微信/H5小游戏的基础。\n","cover":"https://mdn.mozillademos.org/files/224/Canvas_default_grid.png","tags":["canvas","计算公式","数学","三角函数","绘图","入门"],"content":"# canvas从入门到进阶\n\n\n> 使用canvas可以在html5制作出各种绚丽的图表、动画，是制作微信/H5小游戏的基础。\n\n\n## canvas的数学计算公式\n\n\n### 坐标系\n\n在数学中坐标系是一个十字形的，原点在中间。而在canvas中原点在画布的左上角。\n\n![](https://mdn.mozillademos.org/files/224/Canvas_default_grid.png)\n\n### 常用的三角函数\n\n三角函数是初中数学开始学习的知识，但我已经忘记的差不多了，因此这里就多详细整理一下。\n\n1. `sin(α) = y/c`\n\n2. `cos(α) = x/c`\n\n3. `tan(α) = y/x`\n\n\n### 常用的反三角函数\n\n1. `sin(α) = y/c`  =>  `α = arcsin(y/c)`\n\n2. `cos(α) = x/c`  =>  `α = arccos(c/c)`\n\n3. `tan(α) = y/x`  =>  `α = arctan(y/x)`\n\n\n## getContext()\n\n*getContext()*  方法返回canvas上下文环境，可以在创建渲染上下文的时候设置多个属性：\n\n```\n// 二维渲染\ncanvas.getContext(\"2d\")\n\n// 三维渲染(OpenGL ES 2.0)\ncanvas.getContext(\"webgl\")\n\n// 三维渲染(OpenGL ES 3.0)\ncanvas.getContext(\"webg2\")\n\n// 提供功能去替换指定 canvas 的ImageBitmap内容\ncanvas.getContext(\"bitmaprenderer\")\n```\n\n通常情况下，我们使用 `canvas.getContext(\"2d\")`, 即：\n\n```javascript\nvar canvas = document.getElementById(\"canvas\");\nvar ctx = canvas.getContext(\"2d\");\nconsole.log(ctx); // CanvasRenderingContext2D { ... }\n```\n\n## 图形绘制API\n\n### 移动笔触\n\n*moveTo(x, y)*  将笔触移动到指定的坐标x以及y上。\n\n### 路径\n\n*beginPath()*\n新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。\n\n*closePath()*\n闭合路径之后图形绘制命令又重新指向到上下文中。\n\n*stroke()*\n通过线条来绘制图形轮廓。\n\n*fill()*\n通过填充路径的内容区域生成实心的图形。调用fill时，会自动闭合路径。\n\n*clip()*\n将当前正在构建的路径转换为当前的裁剪路径。\n\n### 线\n\n*lineTo(x, y)*  绘制一条从当前位置到指定x以及y位置的直线。如果没有 moveTo 那么第一次 lineTo 的效果等于 moveTo。\n\n### 线型\n\n*lineWidth = value*  设置线条宽度。\n\n*lineCap = type*  设置线条末端样式。\n\n*lineJoin = type*  设定线条与线条间接合处的样式。\n\n*miterLimit = value*  限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。\n\n*getLineDash()*  返回一个包含当前虚线样式，长度为非负偶数的数组。\n\n*setLineDash(segments)*  设置当前虚线样式。\n\n*lineDashOffset = value*  设置虚线样式的起始偏移量。\n\n### 矩形\n\n*fillRect(x, y, width, height)*  绘制一个填充的矩形\n\n*strokeRect(x, y, width, height)*  绘制一个矩形的边框\n\n*clearRect(x, y, width, height)*  清除指定矩形区域，让清除部分完全透明。\n\n*rect(x, y, width, height)*  将一个矩形路径增加到当前路径上\n\n### 实心圆\n\n*arc(x, y, radius, startAngle, endAngle, anticlockwise)*  画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。\n\n### 圆弧\n\n*arcTo(x1, y1, x2, y2, radius)*  根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。\n\n注意：\n\n1. `arc()`函数中表示角的单位是弧度，不是角度。角度与弧度的js表达式: `弧度=(Math.PI/180)*角度`。\n\n2. `arc()`函数如果不闭合路径并且不填充颜色，那么将显示为圆弧。\n\n### 二次贝塞尔曲线及三次贝塞尔曲线\n\n*quadraticCurveTo(cp1x, cp1y, x, y)*  绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。\n\n*bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)*  绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。\n\n### 颜色\n\n设置填充颜色\n\n```\n// 这些 fillStyle 的值均为 '橙色'\nctx.fillStyle = \"orange\";\nctx.fillStyle = \"#FFA500\";\nctx.fillStyle = \"rgb(255,165,0)\";\nctx.fillStyle = \"rgba(255,165,0,1)\";\n```\n\n设置轮廓颜色\n\n```\nctx.strokeStyle = \"orange\";\n```\n\n设置透明度值\n\n```\nctx.globalAlpha = 0.2;\n```\n\n### 渐变\n\n*createLinearGradient(xStart,yStart,xEnd,yEnd).addColorStop(offset,color)*  线性渐变\n\n*createRadialGradient(xStart,yStart,radiusStart,xEnd,yEnd,radiusEnd).addColorStop(offset,color)* 径向渐变\n\n`xstart`:渐变开始点x坐标\n\n`ystart`:渐变开始点y坐标\n\n`xEnd`:渐变结束点x坐标\n\n`yEnd`:渐变结束点y坐标\n\n`radiusStart`：发散开始圆的半径\n\n`radiusEnd`：发散结束圆的半径\n\n`offset`:设定的颜色离渐变结束点的偏移量(0~1)\n\n`color`:绘制时要使用的颜色\n\n### 阴影\n\n*shadowOffsetX = float*\n\nshadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。\n\n*shadowOffsetY = float*\n\nshadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。\n\n*shadowBlur = float*\n\nshadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。\n\n*shadowColor = color*\n\nshadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。\n\n### 填充规则\n\n```\n// 参数： nonzero | evenodd\nctx.fill(\"evenodd\")\n```\n\n“nonzero”是非零环绕原则，也是默认值，“evenodd”为奇偶原则。\n\n通常在填充相交或嵌套路径时使用。\n\n### 文本\n\n*fillText(text, x, y [, maxWidth])*\n在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的.\n\n*strokeText(text, x, y [, maxWidth])*\n在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的.\n\n### 文本样式\n\n*font = value*\n当前我们用来绘制文本的样式. 这个字符串使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif。\n\n*textAlign = value*\n文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。\n\n*textBaseline = value*\n基线对齐选项. 可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。\n\n*direction = value*\n文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。\n\n### 预测量文本宽度\n\n```\nvar text = ctx.measureText(\"foo\");\ntext.width; // 16;\n```\n\n### 图片操作\n\n嵌入图片的操作\n\n```\n// 1. new image()\nvar img = new Image();   // 创建img元素\nimg.onload = function(){\n  // 执行drawImage语句\n}\nimg.src = 'myImage.png'; // 设置图片源地址\n\n// 2. data: url\nimg.src = 'data:image/gif;base64,R0lGODlhCwALAIAAAAAA3pn/ZiH5BAEAAAEALAAAAAALAAsAAAIUhA+hkcuO4lmNVindo7qyrIXiGBYAOw==';\n\n```\n*drawImage(image, x, y, width, height，x2, y2, width2, height2)*\n其中 image 是 image 或者 canvas 对象；x 和 y 是其在目标 canvas 里的起始坐标；width 和 height，这两个参数用来控制 当向canvas画入时应该缩放的大小;x2/y2/width2/height2定义切片的目标显示位置和大小。\n\n\n### Path2D对象\n\nPath2D对象可以把svg等内容画在canvas上。\n\n```\nnew Path2D();     // 空的Path对象\nnew Path2D(path); // 克隆Path对象\nnew Path2D(d);    // 从SVG建立Path对象\nvar p = new Path2D(\"M10 10 h 80 v 80 h -80 Z\"); // 使用svg路径\n```\n### 图案样式\n\n```\nvar img = new Image();\nimg.src = 'someimage.png';\nvar ptrn = ctx.createPattern(img,'repeat');\n```\n注意：\n\n与 drawImage 有点不同，你需要确认 image 对象已经装载完毕，否则图案可能效果不对的。\n\n\n### 状态的保存和恢复\n\n*save()*、*restore()*\nsave 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。\n\n### 移动原点和canvas位置\n\n*translate(x, y)*\ntranslate 方法接受两个参数。x 是左右偏移量，y 是上下偏移量，如右图所示。\n\n### 旋转\n\n*rotate(angle)*\n这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。\n\n![](https://developer.mozilla.org/@api/deki/files/84/=Canvas_grid_rotate.png)\n\n### 缩放\n\n*scale(x, y)*\nscale 方法接受两个参数。x,y 分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩小，比 1.0\n\n### 变形\n\n*transform(m11, m12, m21, m22, dx, dy)*\n\n`m11`：水平方向的缩放\n\n`m12`：水平方向的倾斜偏移\n\n`m21`：竖直方向的倾斜偏移\n\n`m22`：竖直方向的缩放\n\n`dx`：水平方向的移动\n\n`dy`：竖直方向的移动\n\n```\n// 将当前的变形矩阵重置为单位矩阵\nsetTransform(m11, m12, m21, m22, dx, dy) \n\n// 重置当前变形为单位矩阵\nresetTransform()\n```\n\n### 组合\n\n*globalCompositeOperation = type*\n这个属性设定了在画新图形时采用的遮盖策略，其值是一个标识遮盖方式的字符串。\n\n1. `source-over` \n这是默认设置，并在现有画布上下文之上绘制新图形。\n\n2. `source-in` \n新图形只在新图形和目标画布重叠的地方绘制。其他的都是透明的。\n\n3. `source-out` \n在不与现有画布内容重叠的地方绘制新图形\n\n4. `source-atop`\n新图形只在与现有画布内容重叠的地方绘制。\n\n5. `destination-over`\n在现有的画布内容后面绘制新的图形。\n\n6. `destination-in`\n现有的画布内容保持在新图形和现有画布内容重叠的位置。其他的都是透明的。\n\n7. `destination-out`\n现有内容保持在新图形不重叠的地方。\n\n8. `destination-atop`\n现有的画布只保留与新图形重叠的部分，新的图形是在画布内容后面绘制的。\n\n9. `lighter`\n两个重叠图形的颜色是通过颜色值相加来确定的。\n\n11. `copy`\n只显示新图形。\n\n12. `xor`\n图像中，那些重叠和正常绘制之外的其他地方是透明的。\n\n13. `multiply`\n将顶层像素与底层相应像素相乘，结果是一幅更黑暗的图片。\n\n14. `screen`\n像素被倒转，相乘，再倒转，结果是一幅更明亮的图片。\n\n15. `overlay`\nmultiply和screen的结合，原本暗的地方更暗，原本亮的地方更亮。\n\n16. `darken`\n保留两个图层中最暗的像素。\n\n17. `lighten`\n保留两个图层中最亮的像素。\n\n18. `color-dodge`\n将底层除以顶层的反置。\n\n19. `color-burn`\n将反置的底层除以顶层，然后将结果反过来。\n\n20. `hard-light`\n屏幕相乘（A combination of multiply and screen）类似于叠加，但上下图层互换了。\n\n21. `soft-light`\n用顶层减去底层或者相反来得到一个正值。\n\n22. `difference`\n一个柔和版本的强光（hard-light）。纯黑或纯白不会导致纯黑或纯白。\n\n23. `exclusion`\n和difference相似，但对比度较低。\n\n24. `hue`\n保留了底层的亮度（luma）和色度（chroma），同时采用了顶层的色调（hue）。\n\n25. `saturation`\n保留底层的亮度（luma）和色调（hue），同时采用顶层的色度（chroma）。\n\n26. `color`\n保留了底层的亮度（luma），同时采用了顶层的色调(hue)和色度(chroma)。\n\n27. `luminosity`\n保持底层的色调（hue）和色度（chroma），同时采用顶层的亮度（luma）。\n\n\n## 动画\n\ncanvas动画通过重绘出每一帧画面，达到连续的动画效果，重绘是相当费时的，而且性能很依赖于电脑的速度。\n\n### 动画的基本步骤\n\n1. 清空 canvas\n\n  除非接下来要画的内容会完全充满 canvas （例如背景图），否则你需要清空所有。最简单的做法就是用 clearRect 方法。\n\n2. 保存 canvas 状态\n\n  如果你要改变一些会改变 canvas 状态的设置（样式，变形之类的），又要在每画一帧之时都是原始状态的话，你需要先保存一下。\n\n3. 绘制动画图形（animated shapes）\n\n  这一步才是重绘动画帧。\n\n4. 恢复 canvas 状态\n\n  如果已经保存了 canvas 的状态，可以先恢复它，然后重绘下一帧。\n\n> 扩展阅读：\n\n1. [什么是三角函数](https://baike.baidu.com/item/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/1652457)\n\n2. [三角函数教学视频](https://ke.qq.com/course/list/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0?enable_activity_label=0)\n\n3. [Canvas的fill方法之“非零环绕原则nonzero”与“奇偶原则evenodd”](https://www.jianshu.com/p/d4b8b5d931df)\n\n","lasttime":1550224040699}