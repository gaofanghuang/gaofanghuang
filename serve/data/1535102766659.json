{"id":"1535102766659","title":"理解ES6的新数据类型：Symbol\n","summary":"*注意:* symbol作为属性名不能通过 . 的形式添加。\n","tags":["JavaScript","基础知识","扫盲","JS","文档解读","symbol","ES6"],"content":"# 理解ES6的新数据类型：Symbol\n\n## ES6之前的数组类型\n\n在ES6之前JS只有6种数据类型，分别是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。\n\nES6引入了一种新的 *原始数据类型* Symbol，表示独一无二的值，至此JS有了 *7* 种数据类型。\n\n随着JS的版本更新，未来可能会出现其他新的数据类型。\n\n## Symbol 是什么\n\nSymbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。所以，Symbol非常适合做标识符。\n\nSymbol有静态属性，原型上也有methods，但是缺少constructor，所以不能使用 `new Symbol()` , 会报错（见下图）。\n\n![](http://oh8nyy0e4.bkt.clouddn.com/18-8-24/91815025.jpg)\n\n因为生成的Symbol是一个原始类型的值，不是对象，所以不能添加属性。\n\n由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。Symbol值作为对象属性名时，不能用点运算符。在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。\n\n## Symbol 的应用实例\n\n#### Symbol的值\n\n```javascript\n  let s = Symbol();\n  typeof s;\n  // \"symbol\"\n```\n\n#### Symbol是独一无二的\n\n```javascript\n  let s1 = Symbol('abc')\n  let s2 = Symbol('abc')\n  s1 === s2\n  // false\n```\n\n#### Symbol的参数\n\n```javascript\n  let s1 = Symbol('abc');\n  let s2 = Symbol('efg');\n  s1.toString(); \n  // \"Symbol(abc)\"\n  s2.toString(); \n  // \"Symbol(efg)\";\n```\n\n## 获取symbol类型值的三种方式\n\n1. 通过Symbol对象,可以得到一个唯一的symbol值\n\n   ```javascript\n      let s = Symbol();\n   ```\n\n2. Symbol.for(string)\n   可以注册一个symbol，再次调用Symbol.for(string)会得到这个symbol值，区别于Symbol()是唯一的\n   \n   ```javascript\n     let sym = Symbol('abc');\n     const sym1 = Symbol.for('abc');\n     console.log(sym === sym1); //false\n     console.log(sym1 === Symbol.for('abc')); //true\n   ```\n3. Symbol.iterator\n\n   用到对象中，被for...of遍历所用，用于每个object中，所以应该是固定的值。\n\n   ```javascript\n     console.log(Symbol.iterator === Symbol.iterator); \n     //true\n   ```\n \n## 应用场景\n\n由于Symbol的值具有唯一的特性，可以解决变量名，属性名冲突的问题，并切Symbol提出了一些属性和方法，用于过渡以及实现一些特殊的用途，比如对象的迭代器，instanceof的拓展等等。\n\n#### Symbol 在Vue中的应用\n\n使用 *vuex* 时常常需要定义各种常量，以前是这样写：\n\n```javascript\n// types.js\nexport const SHOW_CONTACT = 'SHOW_CONTACT'\n\n```\n使用Symbol后，可以这样写\n\n```javascript\n// types.js\nexport const SHOW_CONTACT = Symbol('show_contact')\n\n```\n\n#### 作为对象的key\n\n> *注意:* symbol作为属性名不能通过 . 的形式添加。\n\n1. 对象[]方括号的形式\n\n  ```javascript\n    const obj = {}\n    const sym = Symbol();\n    obj[sym] = 'syj';\n  ```\n\n2. 对象内部定义\n\n  ```javascript\n    const sym = Symbol();\n    const obj = {\n      [sym]: 'syj'\n    }\n  ```\n\n3. 通过Object.defineProperty定义\n\n  ```javascript\n    const sym = Symbol();\n    const obj = Object.defineProperty({}, sym, {\n      enumerable: true, //可枚举\n      writable: true,  //可赋值运算符改变\n      configurable: true, //可改变，可删除\n      value: 'syj'\n    })\n  ```\n4. symbol类型的key的遍历\n\n  当我们用symbol设置了对象的key以后，他是不会被之前的for...in，Object.keys()遍历出来的，需要用Object.getOwnPropertySymbols()获取，得到一个所有这个对象中的symbol属性名的数组。\n\n  ```javascript\n    const sym1 = Symbol('1');\n    const sym2 = Symbol('2');\n    const obj = {\n      [sym1]: 'syj',\n      [sym2]: 'fy'\n    }\n    const ary = Object.getOwnPropertySymbols(obj);\n    console.log(ary); //[ Symbol(1), Symbol(2) ]\n  ```\n\n> 拓展阅读：\n\n[重构遗留代码（2）：魔术字符串和常量](http://blog.jobbole.com/79323/)\n","lasttime":1547538663965}